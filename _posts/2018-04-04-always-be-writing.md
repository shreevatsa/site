---
layout: post
title: Always be writing
excerpt: Everything
date: 2018-04-04
tags: [draft]

---

This setup was supposed to help me write, but it's not doing that very successfully. I think even with all the allowances I give myself for incomplete sentences etc., there's still some overhead even in creating a post, choosing a title / excerpt, and finally, in committing it to the repo.

Right now it's like email or IM; needs to be like [`talk`](https://en.wikipedia.org/wiki/talk_(software)).

To take that choice out of the loop, I'll probably start dumping everything in this file, and extract things when they are reasonably complete.

Sticking this at some random date in the middle, hope no one notices.

**Table of contents**
* TOC
{:toc}

## Manjul HT

An article on the mathematician Manjul Bhargava, who won the Fields Medal in 2014, from 1997 when he was in his first year of grad school — in Hinduism Today: https://www.hinduismtoday.com/modules/smartsection/item.php?itemid=4868

------

A bit of background: Manjul Bhargava was born in Canada, but grew up in Long Island, New York, where his mother Mira Bhargava was/is a mathematician at Hofstra University. He spent summers in India, where his grandfather, P. L. Bhargava, was a noted Sanskritist (HOD of )

Fn: https://news.hofstra.edu/2014/08/14/prof-mira-bhargavas-son-wins-top-math-prize/ https://twitter.com/hofstrau/status/499945019009429505 

------

> out of the boy! Confident and proud of his Hindu culture and identity, this young Ontario-born son of a chemist father and mathematician mother has proven that he is truly Aryabhata's descendent in mind and spirit. This January he received the prestigious Frank and 

Unlike in India where merely affirming one's Hindu background is almost taken to be a political act, it seems possible elsewhere to have a more straightforward appreciation of one's inheritance. 

Though with other challenges…

------

> The family's staunch vegetarianism did cause some minor clashes in elementary school, but Manjul stood his ground: "Sometimes kids I ate with would make fun of me for not eating meat--'You've never had a hamburger in your life?' they'd ask incredulously. I would remind them that what they were eating were slices of dead cow and pig, and I'd relate cruel and gruesome stories of the slaughterhouse to them. This generally grossed them out enough to never make fun of vegetarianism again. In fact, afterwards many of them stopped eating meat altogether--at least in front of me!" 

Namely: one needs inoculation against many memes / forms of peer pressure; one needs to be much self-assured and confident. Where does that come from?

------

> He cheerfully admits: "I never really liked going to school, and so I rarely attended. Instead, I spent most of my childhood biking, playing tennis and basketball with neighborhood kids, writing, flying kites, reading recreational math books, and learning to play the sitar, guitar, violin and the tabla."
>
> Manjul, the winner of the First Annual New York State Science Talent Search, almost didn't graduate because of his carefree inclination to skip classes that couldn't teach him anything he didn't know already. After all, he had completed all his high school's math and computer courses by ninth grade! Still, he did manage to graduate--as the class valedictorian, no less.

Self-assurance / confidence, extending to knowing that education is much more than schooling (and definitely more than the games one plays to get a job or whatever), seems very important.

------

The last paragraph of [this article](https://www.thehindu.com/sci-tech/science/manjul-bhargava-the-midas-touch-mathematician/article6309323.ece) says:

> He is also keenly interested in linguistics in which he has published research work. It was his grandfather, a linguistics scholar, who taught him Sanskrit and developed his interest in linguistics.

Wonder what this is?

------

https://www.hinduismtoday.com/modules/smartsection/item.php?itemid=4868

https://www.thehindu.com/opinion/op-ed/fields-medal-winner-manjul-bhargava-hope-indian-youth-take-up-research-in-sciences/article6312471.ece

https://thewire.in/history/india-has-to-be-its-own-cultural-ambassador-but-it-has-to-be-scientific-about-it-manjul-bhargava

https://paw.princeton.edu/article/play-fields-math

https://www.princeton.edu/~hindu/about.html -- “faculty advisor”

http://contrarianworld.blogspot.com/2016/06/manjul-bhargava-sanskrit-indian.html (someone's blog post... seems to be “Aravindan Kannaiyan”, a Christian, anti-Brahmin etc, but with a hint of openness and understanding, or at least reasonableness)

https://www.indiatoday.in/india/story/fields-medal-manjul-bhargava-maths-nobel-reaction-indians-204049-2014-08-14

https://en.wikipedia.org/wiki/Manjul_Bhargava

https://www.thehindubusinessline.com/news/professor-of-permutations-percussion-and-poetry/article7457162.ece

http://www.indictoday.com/reviews/being-hindu/

Google search for [manjul bhargava reading gauss]:

- https://paw.princeton.edu/article/play-fields-math
- https://www.mathunion.org/fileadmin/IMU/Prizes/Fields/2014/news_release_bhargava.pdf
- https://plus.maths.org/content/conversation-manjul-bhargava
- http://ieee.scripts.mit.edu/urgewiki/images/2/25/Higher_composition_laws.pdf
- https://www.quantamagazine.org/number-theorist-manjul-bhargava-is-awarded-fields-medal-20140812/

Google search for [p l bhargava]:

- http://plbhargava-conference.org/bio.htm

http://www.heidelberg-laureate-forum.org/blog/laureate/manjul-bhargava/

https://www.dnaindia.com/india/report-maths-wizard-manjul-bhargava-s-kin-in-kerala-elated-2010838

https://www.thehindu.com/todays-paper/tp-national/tp-kerala/payyannur-connection-of-fields-medal-winner/article6315148.ece

http://www.rediff.com/getahead/report/achievers-math-research-is-not-considered-a-reasonable-career-option/20140904.htm

https://timesofindia.indiatimes.com/nri/us-canada-news/PIO-with-mastery-over-Sanskrit-and-tabla-wins-Math-Nobel/articleshow/40199221.cms

https://www.deccanherald.com/content/453907/award-winning-us-prof-teach.html

https://economictimes.indiatimes.com/industry/services/education/manjul-bhargava-to-lead-prime-minister-narendra-modis-teach-in-india-programme/articleshow/45935553.cms

http://www.towntopics.com/wordpress/2018/09/05/princeton-professor-promotes-math-and-magic-at-nyc-museum/

https://www.thehindu.com/news/national/govt-jettisons-scientific-advisory-panels/article24803494.ece

## Gaṇita-kaumudī

See lectures 25-27 of the NPTEL course. Answered [at MathOverflow](https://mathoverflow.net/questions/272090/narayana-and-fermats-factorization-method/311272#311272) and [added to Wikipedia](https://en.wikipedia.org/w/index.php?diff=860961679&oldid=840266843&title=Ganita_Kaumudi&curid=39147431).

## Snooping on DEK archives

Well it's on the public internet...

Sort by datetime.

1973: Some experiments with some Lisp-like language, and with SAIL, and a letter (by wife)

1974: More experiments with SAIL (more sophisticated), probably a memory dump of Greenblatt chess program,

1975: some "failed.txt" which are probably emails that didn't get sent (IIRC mutt also had something like that)

1976: ART(ACP) errata.

1976-03-21 21:33  TEST  .ART [  1,DEK]  1     4275 -- hmm interesting test data. What for?

1976-04-28 10:29  TEMPO .ART [  1,DEK]  1     3510 -- similar

1976-05-15 09:05  TEST  .ART [ART,DEK]  1     4475

Lots more errata etc. Also see a .XGP file. ("Errata et Addenda May 14 1976")

1976-05-23 14:27  BIGART.XGP [ART,DEK]  1    84910

1976-06-10 01:18  DON   .SAI [ART,DEK]  1    33920 -- looks like something that compiles *to* PUB code.

1976-09-21 23:49  DON   .SAI [ART,DEK]  5    34560 -- later version of above.

My guess is, this program converts from the ".MAS" files (see around there) to .PUB files? Some custom syntax to save typing?

Lots of errata etc files, all of these are interesting, but it would be good to first know what they are.

1976-10-29 11:11  SQRT  .SAI [  1,DEK]  1     7680 -- "Floyd's square root problem"

Some christmas letters...

1977-01-17 09:54  OPTBP .SAI [  1,DEK]  1     2560 -- optimal boolean eval

1977-03-29 13:54  JFR   .POX [  1,DEK]  1   101120

-- This is something interesting and I've seen nowhwere discussed. It appears that JFR = John Fredrick Reiser, one of DEK's PhD students. (Thesis: "Analysis of Additive Random Number Generators", 1977) (Also the author of this about SAIL: https://dl.acm.org/citation.cfm?id=892120) And it appears that the "POX" system used was developed by REM ("I also thank Robert Maas for developing the typographical software"), and possibly invented the idea of a "brick" character. (There are POX manuals in other users' archives e.g. https://www.saildart.org/HOW.ALS[UP,DOC]7 .) Surely must have influenced TeX somewhat? The picture of the POX author post this period (what you can find on the internet) doesn't seem too great, sadly.

This by McCarthy mentions POX: http://www-formal.stanford.edu/jmc/office/office.html

See also www1.cs.columbia.edu/~kar/pubsk/seminar.ps --

> Tuesday January 31 (1989 or 1990?)
> Before the start of class􏰍 DEK presented certificates􏰍 typeset with a historic system called
> POX􏰍 to the trivia hunt participants.􏰎 He noted that this may well be the last time that POX would ever be used􏰍 since it will disappear when the machine SAIL is decommissioned

BTW, compare this date with that of the galleys!

1977-04-22 19:38  BELCOR.BAI [  1,DEK]  1     9615 -- not sure how to read this, but possibly interesting.

1977-04-25 18:01  BELFST.SAI [  1,DEK]  1     2560 -- "convert Belfast tapes to ASCII"

1977-04-27 11:58  CORR  .ASC [  1,DEK]  1    11520
1977-04-27 12:00  VOL2A .ASC [  1,DEK]  1   175360
1977-04-27 12:03  VOL2B .ASC [  1,DEK]  1   126720

-- seem to be either dumps or actual souce of the entire text? In definitely some weird format though.

1977-04-27 13:51  BELCOR.SAI [  1,DEK]  1     6400 -- possibly companion to BELCOR.BAI above

1977-05-13 04:59  TEX1  .    [  1,DEK]  1    65280
1977-05-13 04:59  TEX1  .    [  1,DEK]  2    65280
1977-05-13 04:59  TEXDR .AFT [  1,DEK]  1    65280

Aha, here we begin!

1977-05-26 00:17  XGPIT .SAI [  1,DEK]  1     1920
1977-05-26 00:20  SPLINE.SAI [  1,DEK]  1    19200

-- I think these show that the fonts were more interesting.

## Unexpected application of Lagrange's theorem

```
Oct  2: Warning: Due to a known bug, the default Linux document viewer
        evince prints N*N copies of a PDF file when N copies requested.
        As a workaround, use Adobe Reader acroread for printing multiple
        copies of PDF documents, or use the fact that every natural number
        is a sum of at most four squares.
```

Possibly from October 2009.

See https://mathoverflow.net/questions/3596/is-there-a-simple-way-to-compute-the-number-of-ways-to-write-a-positive-integer and https://math.berkeley.edu/computing/wiki/index.php?title=Support:Old_News&oldid=3483 for confirmation.

For another story about mathematics and software bugs, see [here](https://mathoverflow.net/a/11607):

> I don't know any interesting bugs in symbolic algebra packages but I know a true, enlightening and entertaining story about something that looked like a bug but wasn't.$\def\sinc{\operatorname{sinc}}$
>
> Define $\sinc x = (\sin x)/x$.
>
> Someone found the following result in an algebra package:
> $\int_0^\infty dx \sinc x = \pi/2$
>
> They then found the following results:
>
> $\int_0^\infty dx \sinc x \; \sinc (x/3)= \pi/2$
>
> $\int_0^\infty dx \sinc x \; \sinc (x/3) \; \sinc (x/5)= \pi/2$
>
> and so on up to
>
> $\int_0^\infty dx \sinc x \; \sinc (x/3) \; \sinc (x/5) \; \cdots \; \sinc (x/13)= \pi/2$
>
> So of course when they got:
>
>
> $\int_0^\infty dx \sinc x \; \sinc (x/3) \sinc (x/5) \; \cdots \; \sinc (x/15)$$=
> \frac{467807924713440738696537864469}{935615849440640907310521750000}\pi$
>
> they knew they had to report the bug. The poor vendor struggled for a long time trying to fix it but eventually came to the stunning realisation that this result is correct.
>
> These are now known as [Borwein Integrals](http://mathworld.wolfram.com/BorweinIntegrals.html).

by Dan Piponi answered Jan 13 '10 at 2:14 and comments:

> - The actual person at that "poor vendor" was me. I must have spent 3 days on this problem before I figured out that Jon had tricked me. And, indeed, I am an expert in computer algebra, but do not know much Fourier analysis. But Jon's proof for why this is 'correct' is quite geometrical. – Jacques Carette Feb 17 '10 at 4:03
> - @Voyska No, it was not reported as a bug, just as an 'oddity' (or something like that). Jon was not mean, but playful in a devious way. He will be missed. – Jacques Carette Aug 18 '16 at 18:18

See also https://twitter.com/johncarlosbaez/status/1043161440545267713 → https://johncarlosbaez.wordpress.com/2018/09/20/patterns-that-eventually-fail/ for more.

## Exercises in programming style

Started reading this book today. What an excellent idea! I encountered this book through a review. (I think [this one](https://henrikwarne.com/2018/03/13/exercises-in-programming-style/), via [this typically pointless discussion](https://news.ycombinator.com/item?id=16617039). There seems to be a [video](https://www.youtube.com/watch?v=Gw4WJJoDl3U) but I haven't watched it.)

The problem it calls “term frequency”: given a text file, print out the N=25 most common words from it, along with their frequencies.

As in the review, I decided to try solving the problem myself, before reading the examples.

The approach that comes to mind, and what I think of as the “natural” way one (or just I?) would write this program today:

* Keep a map (dictionary) from words to counts: Given the text file, go over each word, incrementing its count in the dictionary.
* After this pass over the text file, you have the dictionary. Make a pass over the dictionary, sorting by *value* (the count). (Maybe keeping only the top N.)
* Print the set finally, in descending order.

Before I thought of actually writing the code, I recalled that something similar (perhaps the same problem?) was the exercise that Bentley gave to Knuth for writing a literate program, and the “review” by the Unix advocate (Doug Mcillroy IIRC?). So I could also write:

```sh
cat file.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head -n 25
```

or something like that.[^wcunix1] (Further tweaks to output if necessary.)

[^wcunix1]: (Actually trying this on the file [`2850-0.txt`](http://www.gutenberg.org/ebooks/2852) gives output like 
    ```
    3181 the
    2205 
    1643 
    1583 of
    1524 and
    1383 to
    1228 a
    1203 i
    1026 that
     897 in
     767 he
     733 was
     709 you
     691 it
     621 his
     580 is
     504 have
     464 had
     449 with
     413 my
     410 for
     406 we
     402 which
     393 as
     350 at
    ```
    so clearly some work is needed.)

When I actually thought of writing down Python code, though, a further shortcut suggested itself:

```py
from collections import Counter

c = Counter()
for line in open('file.txt').readlines():
    for word in line.split():
        c[word] += 1
for (word, count) in c.most_common()[:25]:
    print('%s - %s' % (word, count))
```

There are a bunch of assumptions implicit in all three approaches mentioned so far, which the prologue of the book (where the problem is first properly defined) shows are not actually correct:

* It is wished to ignore capitalization, and
* ’to ignore stop words like “the”, “for”, etc.’

There are many decisions that need to be made if one actually starts writing a program (notwithstanding the fact that we already wrote two programs without making any of these decisions explicitly):

* The first is “what is a word?”
  * The two programs above assumed, more or less, that words are that which are separated by spaces: roughly, that a word is a maximal sequence of non-space characters. (But even they differ when a line ends or starts with a space.)
  * Is this right? What about punctuation, say apostrophes? Surely "doesn't" shouldn't be split at the apostrophe. It seems we want “can't” and “cant”, or “won't” and “wont” to be different words after all—definitely “its” and “it's” aren't the same.
  * But in case of other punctuation, like dashes or full stops (periods), we probably shouldn't count them as part of the word: in the previous paragraph, the final “same.” isn't a word (it's only “same” that is a word), neither is “all—definitely” a single word.
  * What if a line ends with a hyphenated word? Can this happen, and should we detect this and join with the part on the next line?
  * Some linguists will sometimes say that things like “post office” are words; should we care?
* What does it mean to normalize for capitalization?
  * Should we convert everything to lowercase?
  * Or uppercase?
  * Or perhaps the “most common” case of the word should be retained, so that “I” can remain “I”?
  * Are “us” and “US” really the same word?
  * Perhaps we should also keep track of the actual distribution of different cases that a word occurred in, so that if we later decide we need to distinguish these, we don't have to re-read the input file?
* What is meant by ’to ignore stop words like “the”, “for”, etc.’?
  * What is “etc.”? What are the other stop words?
  * When should we ignore them: when reading the file (as early as possible) or perhaps not even in the final output (as late as possible), leaving it to the user to decide which ones are interesting or not?
  * The 

----

## Earliest DMV appointments 

right now (September 30th) (would like one before Thursday, December 13, 2018):

* Daly City: Thursday, December 27, 2018 at 11:00 AM
* Hayward: Monday, December 17, 2018 at 2:40 PM
* San Mateo: No appt
* Fremont: Thursday, December 27, 2018 at 2:40 PM
* REDWOOD CITY: No appt
* Santa Clara: Thursday, December 27, 2018 at 10:20 AM
* San Jose: Tuesday, December 18, 2018 at 11:40 AM
* San Jose DLPC: Monday, December 3, 2018 at 12:40 PM
* Santa Teresa: Tuesday, December 18, 2018 at 2:40 PM
* Los Gatos: Thursday, December 27, 2018 at 10:05 AM
* Capitola: Wednesday, December 12, 2018 at 11:20 AM
* Gilroy: Monday, December 10, 2018 at 2:50 PM
* Watsonville: Wednesday, November 28, 2018 at 11:20 AM
* Hollister: Tuesday, December 4, 2018 at 10:00 AM
* Los Banos: Wednesday, November 28, 2018 at 10:00 AM
* **Salinas: Thursday, November 8, 2018 at 12:20 PM**
* Seaside: Tuesday, November 20, 2018 at 9:00 AM
* San Francisco: Thursday, December 27, 2018 at 2:20 PM
* Pittsburgh: Wednesday, December 12, 2018 at 9:20 AM
* Concord: No appt
* El Cerrito: Wednesday, December 12, 2018 at 2:00 PM
* Walnut Creek: No appt
* OAKLAND CLAREMONT : Wednesday, December 19, 2018 at 1:40 PM
* Oakland Coliseum: Tuesday, November 13, 2018 at 2:20 PM
* PLEASANTON: No appt
* Fremont: Wednesday, December 5, 2018 at 9:20 AM
* Napa: Tuesday, December 11, 2018 at 1:50 PM
* Vallejo: Tuesday, December 4, 2018 at 11:00 AM
* Santa Rosa: Thursday, December 6, 2018 at 8:20 AM
* **KING CITY : Wednesday, October 31, 2018 at 10:40 AM**
* Paso Robles: Thursday, November 8, 2018 at 8:00 AM

---

## Arxiv.org bulk API

Generic API: <https://arxiv.org/help/api/index>

Bulk data S3: <https://arxiv.org/help/bulk_data_s3>

<https://github.com/acohan/arxiv-tools>

## Proving that a number is prime

Imagine I am trying to convince you that a particular (large) number is composite (i.e. not a prime number).

It is easy to prove that a number is a composite: to prove that a number $N$ is composite, we just have to exhibit a number $d$, such that $1 < d < N$ and  $d$ divides $N$. 

(In the terminology of computational complexity theory: This number $d$ serves as a short “certificate” of $N$‘s compositeness. If $\mathrm{PRIMES}$ denotes the set of prime numbers, then this proves that the *complement* of $\mathrm{PRIMES}$ is in $\textsf{NP}$, i.e. that $\mathrm{PRIMES}$ is in $\textsf{co-NP}$.)

It is less trivial to give a short proof that a number is prime. (In the terminology of computational complexity theory: showing that $\mathrm{PRIMES}$ is in $\textsf{NP}$ is less trivial.[^fnaks])

[^fnaks]: Of course, now we know, thanks to the celebrated work of [Manindra Agrawal](https://en.wikipedia.org/wiki/Manindra_Agrawal), [Neeraj Kayal](https://en.wikipedia.org/wiki/Neeraj_Kayal), and [Nitin Saxena](https://en.wikipedia.org/wiki/Nitin_Saxena), that “$\mathrm{PRIMES}$ is in $\mathsf{P}$” — see [1](http://annals.math.princeton.edu/2004/160-2/p12), [2](https://en.wikipedia.org/wiki/AKS_primality_test), [3](http://www.ams.org/notices/200305/fea-bornemann.pdf), etc. This is even less trivial, so beyond the scope of our discussion. :-)

This was first shown by Vaughan Pratt in 1975 (three years after his PhD with Donald Knuth, and a year after the publication of the paper on the Knuth–Morris–Pratt algorithm). The core of the idea is an old one, dating back to Lucas in the mid-19th century, and D. H. Lehmer in 1927. The certificates (short proofs of primality) generated by this method are known as “Pratt certificates”.

These certificates are in fact easy to explain to a high-school student with no number-theory background, from first principles.[^todopratt]

[^todopratt]: (TODO: do this: pick $a$ relatively prime to $N$ and consider powers of $a$ modulo $N$, use pigeonhole-principle to establish that $a^r \equiv 1$ for some $r$, then use the coset argument to prove Lagrange's theorem for this case (gives Fermat-Euler theorem plus order divides $\phi(N)$), then show $\phi(N)$ can't be $N - 1$ if $N$ is not prime, and therefore the Lucas test / Lehmer's theorem, etc.)  Although it's explained at [Wikipedia](https://en.wikipedia.org/w/index.php?title=Primality_certificate&oldid=842984422#Pratt_certificates) and [Pratt's short paper](http://boole.stanford.edu/pub/SucCert.pdf#page=3), here it is again.



A similar slow method is found in `pari` as `isprime` when you pass `1` as the second argument. It is documented [here](https://www-fourier.ujf-grenoble.fr/~parisse/giac/doc/en/cascmd_en/node43.html) as:

> This returns the coefficients giving the proof of primality by the p - 1 Selfridge-Pocklington-Lehmer test

and [here](https://pari.math.u-bordeaux.fr/faq.html#primetest) as:

> `isprime(N)` first performs an `ispseudoprime` test. If N is larger than 264, Selfridge-Pocklington-Lehmer p-1 test is performed if N-1 is smooth (factored part is larger than N<sup>1/3</sup>; Konyagin-Pomerance or more involved algorithms based on lattice reduction are not implemented). Otherwise we use APR-CL (Adleman-Pomerance-Rumely, Cohen-Lenstra).

and [here](https://pari.math.u-bordeaux.fr/archives/pari-announce-18/msg00006.html) as:

> * now that we have primecert, isprime(n,1) no longer outputs a certificate and no longer uses APRCL for large prime divisors of n-1; it now implements pure Pocklington-Lehmer-Selfridge and is very slow; use primecert(n) !

and [here](https://cs.stackexchange.com/a/23263/891) as:

> - `isprime(x,1)` Uses Pocklington–Lehmer test (simple n−1).

— I think I figured it out from [here](https://programmingpraxis.com/2012/09/28/pocklingtons-n-1-primality-prover/) (and a bit from [here](https://warwick.ac.uk/fac/sci/maths/research/events/2012-2013/numbertheory/ntgc/talks/warwbeam.pdf), also [badly written on Wikipedia](https://en.wikipedia.org/w/index.php?title=Pocklington_primality_test&oldid=807800293#Generalized_Pocklington_method)): instead of only showing that $a^{(n-1)/q} \not\equiv 1 \pmod N$, i.e. that $N \nmid (a^{(n-1)/q} - 1)$, we show that $N \perp  (a^{(n-1)/q} - 1)$ — using here $x \perp y$ to mean that $\gcd(x, y) = 1$ — and in return we only have to prove it for primes in some “factored part” of $(N - 1)$ that is at least $\sqrt{N}$.

Example:

```
pari.isprime(10000000000000000369475456880582265409809179829842688451922778552150543659347219597216513109705408327446511753687232667314337003349573404171046192448274699, 1)
```

```
[2, 2, 1; 773, 2, 1; 3430787131, 2, 1; 177830900711, 2, 1; 5736810279563022496918256153681231, 2, [2, 7, 1; 5, 2, 1; 11, 2, 1; 719090842404611, 2, 1]]
```

— this took something like 4 hours for a 155​-digit prime.

I'm not sure how to read this, but here are the facts:

* With N = 10000 00000 00000 00369 47545 68805 82265 40980 91798 29842 68845 19227 78552 15054 36593 47219 59721 65131 09705 40832 74465 11753 68723 26673 14337 00334 95734 04171 04619 24482 74699 (spaces for clarity), the factorization of N - 1 is [2 , 773 , 34307 87131 , 17783 09007 11 , 57368 10279 56302 24969 18256 15368 1231 , 18480 72574 75428 38412 29608 79808 05424 74912 36118 10555 00369 77261 35763 76775 78396 96558 97497 97900 37414 03]

* We can check that $2^{(N-1)/2} \not\equiv 1\pmod{N}$, that $2^{(N-1)/773} \not\equiv 1$, that $2^{(N-1)/3430787131} \not\equiv 1$, etc. Try the following in Sage:

  ```py
  fs = [2, 773, 3430787131, 177830900711, 5736810279563022496918256153681231, 1848072574754283841229608798080542474912361181055500369772613576376775783969655897497979003741403]
  
  product = 1
  for f in fs:
      product *= f
  product == N1 - 1
  
  for f in fs:
      print 2.powermod((N1 - 1) / f, N1) != 1
  ```

* Finally, we can generate similar certificates for each of those primes:

  ```py
  for f in fs:
      print f
      print pari.isprime(f, 1)
  ```

  gives

  ```py
  2
  1
  773
  [2, 2, 1; 193, 2, 1]
  3430787131
  [2, 2, 1; 3, 2, 1; 5, 2, 1; 89, 2, 1; 142771, 2, 1]
  177830900711
  [2, 7, 1; 5, 2, 1; 19, 2, 1; 257, 2, 1; 479, 2, 1; 7603, 2, 1]
  5736810279563022496918256153681231
  [2, 7, 1; 5, 2, 1; 11, 2, 1; 719090842404611, 2, 1]
  1848072574754283841229608798080542474912361181055500369772613576376775783969655897497979003741403
  [2, 2, 1; 3, 5, 1; 233, 2, 1; 13523, 2, 1; 38377, 2, 1; 11761095715573, 2, 1; 371860136940003389, 2, 1]
  ```


10000 000000 000000 369475 456880 582265 409809 179829 842688 451922 778552 150543 659347 219597 216513 109705 408327 446511 753687 232667 314337 003349 573404 171046 192448 275666 (155 digits) = 2 × 3 × 93581 × 782764 541753 × 22752 541933 520162 611588 132845 788925 987350 684817 349828 720701 506059 412842 231831 122206 814184 277933 099371 796471 926801 319705 877117 230314 257127 (137 digits)

A later development is “elliptic curve primality proving”: [Wikipedia 1](https://en.wikipedia.org/w/index.php?title=Primality_certificate&oldid=842984422#Atkin%E2%80%93Goldwasser%E2%80%93Kilian%E2%80%93Morain_certificates), [Wikipedia 2](https://en.wikipedia.org/w/index.php?title=Elliptic_curve_primality&oldid=847730025), [paper 1](http://www.mat.uniroma2.it/~geo2/goldwasserkilian.pdf). This is what is used by the program [Primo](http://www.ellipsa.eu/public/primo/primo.html) by Marcel Martin, considered the gold-standard of primality-proving programs.

For more on the theory and practice of verifying Primo certificates, see [here](https://math.stackexchange.com/a/1686428), [here](https://math.stackexchange.com/a/2303048), [here](https://www.mersenneforum.org/showthread.php?t=14086), [here](https://github.com/tomato42/ecpp-verifier), [here](https://www.quora.com/What-is-the-fastest-deterministic-primality-test/answer/Dana-Jacobsen).

## Factorizing numbers using Fermat's method (Narayana's method)

Fermat's method of factorization (which should properly be called Narayana's method; see below) is useful when trying to find the factors of a number $N$ that happens to have a factorization of the form $N = pq$, where $p$ and $q$ are very close to each other.

The idea is this: suppose we are given an odd number $N$ (for even numbers it's easy to find at least one factor, namely 2!) such that $N = pq$ (where $p$ and $q$ are unknown, but obviously both must be odd). Then if we let $a = (p + q)/2$ and $b = (q - p)/2$, then $p = a - b$ and $q = a + b$, and therefore $N = pq = (a - b)(a + b) = a^2 - b^2$. Conversely, if we can write $N$ in the form $N = a^2 - b^2$, then we can find $p$ and $q$ as $a - b$ and $a + b$ respectively.

This is what the method tries to do: write $N$ as

$$\begin{equation}N = a^2 - b^2 \tag{1}\label{fermat1}\end{equation}$$

How can we use $\eqref{fermat1}$, short of randomly trying integers $a$ and $b$? One way would be to rewrite $\eqref{fermat1}$ so that $a$ is on the right-hand side:

$$\begin{equation}N + b^2 = a^2\tag{2}\label{fermat2}\end{equation}$$

This would suggest trying successive values of $b$ until we find one for which $N + b^2$ is a square. Better is to rewrite $\eqref{fermat1}$ such that $b$ is on the RHS:

$$\begin{equation}a^2 - N = b^2\tag{3}\label{fermat3}\end{equation}$$

This suggests the following algorithm: Try successive values of $a$ (such that $a^2 \ge N$) until you find one for which $a^2 - N$ is a square. And this is Fermat's factorization method.

Actually, Pierre de Fermat, after whom it is named, lived from 1607 to 1665. The method occurs much earlier, in the work of Narayana Pandita. In the Sanskrit text *Gaṇita-kaumudī*, written around 1356, Nārāyaṇa describes exactly this method. In the algorithmic style that is typical of Indian mathematics,[^indcomp] the computational details are refined and worked out, and what is presented is a practical algorithm:

[^indcomp]: The algorithmic flavour of Indian mathematics is IMO not sufficiently appreciated. When Indian mathematics was first translated into English and other European languages, it was under-valued (among other reasons) as modern mathematics at the time was under the thrall of the Greek axiomatic method. With the rise of computer science, more attention today, by people with a computational mindset, would lead to better translations and understanding. Knuth has written somewhere about how he was reading a translation of some Sanskrit mathematical text and could relate to the author, even if the author didn't seem to have been understood properly by the translator.

* Square numbers can be (further) factorized using the factorization of their square root.

* So given a non-square number $N$, write it as $N = A^2 + r$, where $A^2$ is the closest square number less than $N$.

* (The idea, as mentioned earlier, is to try values of $a^2 - N$, for successive numbers $a = A + 1$, $a = A + 2$, etc., and check whether they are squares. Note that $(A + 1)^2 - r = A^2 + 2A+1 - r$ and so on. This Nārāyaṇa presents as follows.)

* If it so happens that $2A + 1 - r$ is a square (say $b^2$), then we are done: $N = (A + 1 - b)(A + 1 + b)$.

  > apada-pradasya rāśeḥ padam āsannaṃ dvi-saṅguṇaṃ saikam /
  >
  > mūlāvaśeṣa-hīnaṃ vargaś cet kṣepakaś ca kriti-siddhau //

* (Else, we have to move on, to trying $A + 2$, and so on. Note that $(A + 2)^2 - (A+1)^2 = 2A + 3$, and in general $(A+k)^2 - (A+k-1)^2 = 2k-1$. So we can move to successive squares by adding successive odd numbers. This Nārāyaṇa presents as follows.)

* Else, if $2A + 1 - r$ is not a square, add $(2A + 3)$ and so on, until and keep doing this until you get a square.

  > vargo na bhavet pūrvāsannapadaṃ dvi-guṇitaṃ tri-saṃyuktam /
  >
  > adyād uttara-vṛddhyā tāvad yavad bhaved vargaḥ //

### Example

Here is a worked-out example, using Nārāyaṇa's method. Consider the 309-digit number N = 10000 00000 00000 00738 95091 37611 64544 47082 96833 71185 86600 68128 90654 88870 73921 09201 08053 65341 56624 34024 61288 17909 55097 21638 67047 87165 76291 33813 53272 85613 36109 27478 66891 04494 71945 61369 77224 93690 66504 00823 90307 77919 04596 57524 86653 37281 26322 86420 48452 96156 70829 12176 87090 47243 84458 70151 97251 11825 42414 56911 69344 9233. (This number arises from [this nice post](https://manasataramgini.wordpress.com/2018/10/05/a-laymans-overview-of-the-arithmetic-of-encryption/).)

Normally, factoring such large numbers is beyond the reach of computers: there are [240-digit numbers](https://en.wikipedia.org/w/index.php?title=RSA_numbers&oldid=860651860#RSA-240) that haven't been factored since being offered as a [challenge](https://en.wikipedia.org/w/index.php?title=RSA_Factoring_Challenge&oldid=862587721) in 1991. But in this case, $N$ happens to be the product of two nearby primes, so it turns out we can factor it easily. We write $N$ as $A^2 + r$ where 

A = 10000 00000 00000 00369 47545 68805 82265 40980 91798 29842 68845 19227 78552 15054 36593 47219 59721 65131 09705 40832 74465 11753 68723 26673 14337 00334 95734 04171 04619 24482 75182 (has 155 digits), and 

r = 20000 00000 00000 00738 95091 37611 64530 81961 83596 59685 37690 38455 57104 30108 73186 94439 19443 30262 19410 81665 48930 23507 37446 53346 28674 00669 91468 08342 09238 48963 16109 (also has 155 digits).

Then we calculate $(2A + 1 - r)$. This works out to be just $234256$, which is exactly the square of $484$. The problem is already solved, in just the very first step! What we've found is that with $b = 484$ and $a = A + 1$, we have $N = a^2 - b^2 = (a - b)(a + b)$, so the factors are

$p = (a - b)$ which is 10000 00000 00000 00369 47545 68805 82265 40980 91798 29842 68845 19227 78552 15054 36593 47219 59721 65131 09705 40832 74465 11753 68723 26673 14337 00334 95734 04171 04619 24482 74699 (has 155 digits) and

$q = (a + b)$ which is 10000 00000 00000 00369 47545 68805 82265 40980 91798 29842 68845 19227 78552 15054 36593 47219 59721 65131 09705 40832 74465 11753 68723 26673 14337 00334 95734 04171 04619 24482 75667 (has 155 digits).

Both of these can be verified to be prime, so this is the complete factorization of $N$.















----


